# Logical Expressisons

- test the value of an expression to see if it's T or F
- ex. if statement
  - i < j -> true means i less than j false means i geq j

- In many languages ths would have a special boolean type
- however in C it yields an integer; 0 == false or 1 == true

## Relational operators
```
<       less than
>       greater than
<=      less than or equal to
>=      greater than or equal to
```

- produce either 0 or 1
- can compare ints or floats
- operands of mixed types allowed
- left associative

- i < j < k is legal in C but it means (i < j) < k because of left associativity.
  - so it first tests i < j then compares the 0 or 1 to k
  - does NOT test if j is between i and k

## Equality operators
```
==      equal to
!=      not equal to
```

- produce either 0 or 1
- lower precedence than relational
- left associative

- i < j == j < k is equivalent to (i < j) == (j < k)
  - true f both comparisons are true or both comparisons are false

- You can be clever and exploit the fact that these return ints
- Ex. ( i >= j ) + ( i==j ) is either 0, 1, or 2 depending on whether i is less than/greater than/equal to j.
- Doing stuff like that makes programs harder to understand though

## Logical operators
```
!       logical negation
&&      logical and
||      logical or
```

- ! is unary while the others are binary
- produce 0 or 1
- often operands have a value of 0 or 1 but not required
- logical operators treat any nonzero operand as true and any zero as false
  - !expr == 1 if expr == 0
  - expr1 && expr2 == 1 if expr1 and expr2 are both nonzero
  - expr1 || expr2 == 1 if expr1 or expr2 or both have a nonzero value
- in all other cases they're zero

&& and || perform "short circuit" eval of their operands
- first evaluate the left
- then the right
- if the value can be deduced from the left alone then the right isn't evaluated

ex.
```
(i != 0) && (j / i > 0)
```
1. evaluate `(i != 0)`
2. if `i` not equal to `0` then we need to evaluate `(j / i > 0)`

Note: side effects of logical expressions!
- short circuit nature of && and || means side effects won't always occur
- for example 
```
i > 0 && ++j > 0
```
- although j is apparently incremented as a side effect of evaluating the expression this isn't always the case
- it might decide i > 0 is 0 and cut the evaluation short
- you can solve it by putting the incrementy case first
  - or just increment j separately...

- ! has same precedence as unary + and -
- precedence of && and || is less than relational and equality operators 
- ! is right associative and && and || are left associative

